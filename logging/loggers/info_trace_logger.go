// Copyright 2017 Monax Industries Limited
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package loggers

import (
	kitlog "github.com/go-kit/kit/log"
	"github.com/hyperledger/burrow/logging/structure"
	"github.com/hyperledger/burrow/logging/types"
)

type infoTraceLogger struct {
	infoContext  kitlog.Logger
	traceContext kitlog.Logger
	outputLogger *kitlog.SwapLogger
}

// Interface assertions
var _ types.InfoTraceLogger = (*infoTraceLogger)(nil)
var _ kitlog.Logger = (types.InfoTraceLogger)(nil)

// Create an InfoTraceLogger by passing the initial outputLogger.
func NewInfoTraceLogger(outputLogger kitlog.Logger) types.InfoTraceLogger {
	// We will never halt the progress of a log emitter. If log output takes too
	// long will start dropping log lines by using a ring buffer.
	swapLogger := new(kitlog.SwapLogger)
	swapLogger.Swap(outputLogger)
	wrappedOutputLogger := wrapOutputLogger(swapLogger)
	return &infoTraceLogger{
		outputLogger: swapLogger,
		// logging contexts
		infoContext: kitlog.With(wrappedOutputLogger,
			structure.ChannelKey, types.InfoChannelName,
			structure.LevelKey, types.InfoLevelName,
		),
		traceContext: kitlog.With(wrappedOutputLogger,
			structure.ChannelKey, types.TraceChannelName,
			structure.LevelKey, types.TraceLevelName,
		),
	}
}

func NewNoopInfoTraceLogger() types.InfoTraceLogger {
	return NewInfoTraceLogger(nil)
}

func (l *infoTraceLogger) With(keyvals ...interface{}) types.InfoTraceLogger {
	return &infoTraceLogger{
		outputLogger: l.outputLogger,
		infoContext:  kitlog.With(l.infoContext, keyvals...),
		traceContext: kitlog.With(l.traceContext, keyvals...),
	}
}

func (l *infoTraceLogger) WithPrefix(keyvals ...interface{}) types.InfoTraceLogger {
	return &infoTraceLogger{
		outputLogger: l.outputLogger,
		infoContext:  kitlog.WithPrefix(l.infoContext, keyvals...),
		traceContext: kitlog.WithPrefix(l.traceContext, keyvals...),
	}
}

func (l *infoTraceLogger) Info(keyvals ...interface{}) error {
	return l.infoContext.Log(keyvals...)
}

func (l *infoTraceLogger) Trace(keyvals ...interface{}) error {
	return l.traceContext.Log(keyvals...)
}

func (l *infoTraceLogger) SwapOutput(infoLogger kitlog.Logger) {
	l.outputLogger.Swap(infoLogger)
}

// If logged to as a plain kitlog logger presume the message is for Trace
// This favours keeping Info reasonably quiet. Note that an InfoTraceLogger
// aware adapter can make its own choices, but we tend to think of logs from
// dependencies as less interesting than logs generated by us or specifically
// routed by us.
func (l *infoTraceLogger) Log(keyvals ...interface{}) error {
	return l.Trace(keyvals...)
}

// Wrap the output loggers with a a set of standard transforms, a non-blocking
// ChannelLogger and an outer context
func wrapOutputLogger(outputLogger kitlog.Logger) kitlog.Logger {
	return NonBlockingLogger(BurrowFormatLogger(VectorValuedLogger(outputLogger)))
}
